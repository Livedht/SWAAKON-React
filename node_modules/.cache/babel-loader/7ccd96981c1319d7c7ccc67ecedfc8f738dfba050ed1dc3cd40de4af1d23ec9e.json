{"ast":null,"code":"import OpenAI from 'openai';\nimport { supabase } from './supabase';\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true\n});\n\n// Legg til disse konstantene øverst i filen\nconst COST_PER_1K_TOKENS = {\n  'gpt-3.5-turbo-0125': {\n    // Nyeste og billigste versjonen\n    input: 0.0001,\n    // $0.0001 / 1K tokens\n    output: 0.0002 // $0.0002 / 1K tokens\n  },\n  'text-embedding-3-large': {\n    input: 0.00013,\n    output: 0.00013\n  }\n};\n\n// Cache for translations\nconst translationCache = new Map();\nconst analysisCache = new Map();\n\n// Funksjon for å logge API-kostnader\nconst logApiCost = async (endpoint, model, inputTokens, outputTokens = 0) => {\n  try {\n    const inputCost = inputTokens / 1000 * COST_PER_1K_TOKENS[model].input;\n    const outputCost = outputTokens / 1000 * COST_PER_1K_TOKENS[model].output;\n    const totalCost = inputCost + outputCost;\n\n    // Hent gjeldende bruker\n    const {\n      data: {\n        user\n      }\n    } = await supabase.auth.getUser();\n    console.log('Logging API cost:', {\n      endpoint,\n      model,\n      inputTokens,\n      outputTokens,\n      totalCost,\n      user: user === null || user === void 0 ? void 0 : user.email\n    });\n    const {\n      data,\n      error\n    } = await supabase.from('api_costs').insert([{\n      endpoint,\n      model,\n      tokens_used: inputTokens + outputTokens,\n      cost_usd: totalCost,\n      user_id: user === null || user === void 0 ? void 0 : user.id,\n      user_email: user === null || user === void 0 ? void 0 : user.email\n    }]).select();\n    if (error) {\n      console.error('Error inserting API cost:', error);\n      throw error;\n    }\n    console.log('Successfully logged API cost:', data);\n    return data;\n  } catch (error) {\n    console.error('Error in logApiCost:', error);\n  }\n};\n\n// Normalize the embedding vector to unit length\nconst normalizeVector = vector => {\n  const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n  return vector.map(val => val / magnitude);\n};\n\n// Clean and format text for validation\nconst cleanTextForValidation = text => {\n  // Remove bullet points and other special characters but keep the text\n  return text.replace(/[•·⋅‣⁃◦∙]/g, '') // Remove bullet points\n  .replace(/[\\n\\r]+/g, ' ') // Replace newlines with spaces\n  .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\n  .trim();\n};\n\n// Validate text input\nconst isValidInput = text => {\n  // First, let's clean the text for validation\n  const cleanedText = cleanTextForValidation(text);\n\n  // Split into words, filtering out empty strings\n  const words = cleanedText.split(/\\s+/).filter(word => word.length > 0);\n  console.log('Validation stats:', {\n    originalLength: text.length,\n    cleanedLength: cleanedText.length,\n    wordCount: words.length,\n    sampleWords: words.slice(0, 5)\n  });\n\n  // Check word count\n  if (words.length < 10) {\n    console.log('Text too short, needs at least 10 words. Word count:', words.length);\n    return false;\n  }\n  if (words.length > 2000) {\n    console.log('Text too long, exceeds 2000 words');\n    return false;\n  }\n\n  // Check for meaningful content\n  const meaningfulWords = words.filter(word => word.length >= 2);\n  const meaningfulRatio = meaningfulWords.length / words.length;\n  if (meaningfulRatio < 0.5) {\n    console.log('Too many short or meaningless words. Meaningful ratio:', meaningfulRatio);\n    return false;\n  }\n\n  // Check character distribution\n  const letterCount = cleanedText.replace(/[^a-zA-ZæøåÆØÅ]/g, '').length;\n  const totalLength = cleanedText.length;\n  const letterRatio = letterCount / totalLength;\n  if (letterRatio < 0.3) {\n    // Reduced from 0.4 to 0.3 to accommodate more special characters\n    console.log('Too few letters in text. Letter ratio:', letterRatio);\n    return false;\n  }\n  return true;\n};\n\n// Simple hash function for text\nconst hashText = text => {\n  let hash = 0;\n  for (let i = 0; i < text.length; i++) {\n    const char = text.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return hash;\n};\n\n// Function to detect if text is in English\nconst isEnglishText = text => {\n  // Check for absence of Norwegian characters\n  const hasNorwegianChars = /[æøåÆØÅ]/.test(text);\n  if (hasNorwegianChars) return false;\n\n  // Common English words that don't exist in Norwegian\n  const englishWords = /\\b(the|and|is|are|was|were|this|that|these|those|with|for)\\b/i;\n  return englishWords.test(text);\n};\n\n// Function to translate text between Norwegian and English\nconst translateText = async (text, targetLanguage) => {\n  try {\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4-turbo-preview\",\n      messages: [{\n        role: \"system\",\n        content: `You are a professional translator specializing in academic and technical content. \n                    Translate the following text to ${targetLanguage === 'en' ? 'English' : 'Norwegian (Bokmål)'}, \n                    maintaining academic terminology and professional tone.`\n      }, {\n        role: \"user\",\n        content: text\n      }],\n      temperature: 0.3\n    });\n    await logApiCost('translation', 'gpt-4-turbo-preview', response.usage.prompt_tokens, response.usage.completion_tokens);\n    return response.choices[0].message.content;\n  } catch (error) {\n    console.error('Translation error:', error);\n    throw error;\n  }\n};\n\n// Legg til export for generateEmbedding\nexport const generateEmbedding = async (text, translateFirst = false) => {\n  try {\n    let norwegianText = text;\n    let englishText = text;\n    const isEnglish = isEnglishText(text);\n    if (isEnglish) {\n      norwegianText = await translateText(text, 'nb');\n    } else if (translateFirst) {\n      englishText = await translateText(text, 'en');\n    }\n    const contextualizeText = inputText => `Task: Compare academic course descriptions to find similarities in learning outcomes, content, and themes.\n\nCourse Information:\n${inputText}\n\nConsider:\n- Learning outcomes and competencies\n- Course content and themes\n- Academic level and complexity\n- Teaching methods and approach`;\n    const [norwegianEmbedding, englishEmbedding] = await Promise.all([openai.embeddings.create({\n      model: \"text-embedding-3-large\",\n      input: contextualizeText(norwegianText),\n      encoding_format: \"float\",\n      dimensions: 2000\n    }), openai.embeddings.create({\n      model: \"text-embedding-3-large\",\n      input: contextualizeText(englishText),\n      encoding_format: \"float\",\n      dimensions: 2000\n    })]);\n    await logApiCost('embeddings', 'text-embedding-3-large', norwegianEmbedding.usage.total_tokens);\n    await logApiCost('embeddings', 'text-embedding-3-large', englishEmbedding.usage.total_tokens);\n    return {\n      norwegian: norwegianEmbedding.data[0].embedding,\n      english: englishEmbedding.data[0].embedding,\n      isEnglishInput: isEnglish\n    };\n  } catch (error) {\n    console.error('Error generating embeddings:', error);\n    throw error;\n  }\n};\n\n// Legg til export for generateOverlapExplanation\nexport const generateOverlapExplanation = async (courseA, courseB, similarityScore) => {\n  const cacheKey = `${courseA.name}-${courseB.kurskode}`;\n  if (analysisCache.has(cacheKey)) {\n    return analysisCache.get(cacheKey);\n  }\n  const isSameCourse = courseA.name === courseB.kursnavn || courseA.code && courseA.code === courseB.kurskode;\n  const prompt = `\nDu er en akademisk rådgiver som skal forklare overlapp mellom to kurs. \n${isSameCourse ? 'Dette er samme kurs som sammenlignes med seg selv.' : ''}\nGenerer en strukturert forklaring på norsk (maks 250 ord) som sammenligner disse kursene:\n\nKurs A: ${courseA.name}\n${courseA.content}\n${courseA.literature ? `Pensum: ${courseA.literature}` : ''}\n\nKurs B: ${courseB.kursnavn} (${courseB.kurskode})\n${courseB.description || courseB.course_content || 'Ingen beskrivelse tilgjengelig'}\n${courseB.pensum ? `Pensum: ${courseB.pensum}` : ''}\n\nSimilaritet: ${similarityScore}%\n\nFormater svaret slik:\n\n### KURSSAMMENLIGNING\n▸ ${isSameCourse ? 'Dette er samme kurs sammenlignet med seg selv' : 'Kort introduksjon av begge kursene'}\n▸ Overordnet vurdering av overlapp (${similarityScore}% likhet)\n\n### HOVEDFOKUS\n• Sentrale temaer og konsepter${isSameCourse ? ' i kurset' : ' som overlapper'}\n${!isSameCourse ? `• Unike aspekter i ${courseA.name}\n• Unike aspekter i ${courseB.kursnavn}` : ''}\n\n### LÆRINGSUTBYTTE\n• Sentrale kompetanser${isSameCourse ? ' som kurset gir' : ' som overlapper'}:\n  - [Liste med kompetanser]\n${!isSameCourse ? `• Unike kompetanser i ${courseA.name}:\n  - [Liste med unike ferdigheter]\n• Unike kompetanser i ${courseB.kursnavn}:\n  - [Liste med unike ferdigheter]` : ''}\n\n### ANBEFALING\n▸ ${isSameCourse ? 'Dette er samme kurs, så det er ikke relevant å ta det flere ganger' : 'Er det hensiktsmessig å ta begge kursene?'}\n${!isSameCourse ? `▸ Anbefalt rekkefølge (hvis relevant)\n▸ Målgruppe og tilpasning` : ''}`;\n  try {\n    const response = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo-0125\",\n      // Nyeste og billigste versjonen\n      messages: [{\n        role: \"user\",\n        content: prompt\n      }],\n      temperature: 0.7,\n      max_tokens: 1000\n    });\n    await logApiCost('explanations', 'gpt-3.5-turbo-0125', response.usage.prompt_tokens, response.usage.completion_tokens);\n    const explanation = response.choices[0].message.content.trim();\n    analysisCache.set(cacheKey, explanation);\n    return explanation;\n  } catch (error) {\n    console.error('Error generating overlap explanation:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["OpenAI","supabase","openai","apiKey","process","env","REACT_APP_OPENAI_API_KEY","dangerouslyAllowBrowser","COST_PER_1K_TOKENS","input","output","translationCache","Map","analysisCache","logApiCost","endpoint","model","inputTokens","outputTokens","inputCost","outputCost","totalCost","data","user","auth","getUser","console","log","email","error","from","insert","tokens_used","cost_usd","user_id","id","user_email","select","normalizeVector","vector","magnitude","Math","sqrt","reduce","sum","val","map","cleanTextForValidation","text","replace","trim","isValidInput","cleanedText","words","split","filter","word","length","originalLength","cleanedLength","wordCount","sampleWords","slice","meaningfulWords","meaningfulRatio","letterCount","totalLength","letterRatio","hashText","hash","i","char","charCodeAt","isEnglishText","hasNorwegianChars","test","englishWords","translateText","targetLanguage","response","chat","completions","create","messages","role","content","temperature","usage","prompt_tokens","completion_tokens","choices","message","generateEmbedding","translateFirst","norwegianText","englishText","isEnglish","contextualizeText","inputText","norwegianEmbedding","englishEmbedding","Promise","all","embeddings","encoding_format","dimensions","total_tokens","norwegian","embedding","english","isEnglishInput","generateOverlapExplanation","courseA","courseB","similarityScore","cacheKey","name","kurskode","has","get","isSameCourse","kursnavn","code","prompt","literature","description","course_content","pensum","max_tokens","explanation","set"],"sources":["C:/Users/A1510207/OneDrive - BI Norwegian Business School (BIEDU)/Documents/Dev prosjekter/SWAAKON-React/src/services/openai.js"],"sourcesContent":["import OpenAI from 'openai';\nimport { supabase } from './supabase';\n\nconst openai = new OpenAI({\n    apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n    dangerouslyAllowBrowser: true\n});\n\n// Legg til disse konstantene øverst i filen\nconst COST_PER_1K_TOKENS = {\n    'gpt-3.5-turbo-0125': {  // Nyeste og billigste versjonen\n        input: 0.0001,   // $0.0001 / 1K tokens\n        output: 0.0002   // $0.0002 / 1K tokens\n    },\n    'text-embedding-3-large': {\n        input: 0.00013,\n        output: 0.00013\n    }\n};\n\n// Cache for translations\nconst translationCache = new Map();\nconst analysisCache = new Map();\n\n// Funksjon for å logge API-kostnader\nconst logApiCost = async (endpoint, model, inputTokens, outputTokens = 0) => {\n    try {\n        const inputCost = (inputTokens / 1000) * COST_PER_1K_TOKENS[model].input;\n        const outputCost = (outputTokens / 1000) * COST_PER_1K_TOKENS[model].output;\n        const totalCost = inputCost + outputCost;\n        \n        // Hent gjeldende bruker\n        const { data: { user } } = await supabase.auth.getUser();\n        \n        console.log('Logging API cost:', {\n            endpoint,\n            model,\n            inputTokens,\n            outputTokens,\n            totalCost,\n            user: user?.email\n        });\n\n        const { data, error } = await supabase\n            .from('api_costs')\n            .insert([{\n                endpoint,\n                model,\n                tokens_used: inputTokens + outputTokens,\n                cost_usd: totalCost,\n                user_id: user?.id,\n                user_email: user?.email\n            }])\n            .select();\n\n        if (error) {\n            console.error('Error inserting API cost:', error);\n            throw error;\n        }\n\n        console.log('Successfully logged API cost:', data);\n        return data;\n    } catch (error) {\n        console.error('Error in logApiCost:', error);\n    }\n};\n\n// Normalize the embedding vector to unit length\nconst normalizeVector = (vector) => {\n    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n    return vector.map(val => val / magnitude);\n};\n\n// Clean and format text for validation\nconst cleanTextForValidation = (text) => {\n    // Remove bullet points and other special characters but keep the text\n    return text\n        .replace(/[•·⋅‣⁃◦∙]/g, '') // Remove bullet points\n        .replace(/[\\n\\r]+/g, ' ') // Replace newlines with spaces\n        .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\n        .trim();\n};\n\n// Validate text input\nconst isValidInput = (text) => {\n    // First, let's clean the text for validation\n    const cleanedText = cleanTextForValidation(text);\n\n    // Split into words, filtering out empty strings\n    const words = cleanedText.split(/\\s+/).filter(word => word.length > 0);\n\n    console.log('Validation stats:', {\n        originalLength: text.length,\n        cleanedLength: cleanedText.length,\n        wordCount: words.length,\n        sampleWords: words.slice(0, 5)\n    });\n\n    // Check word count\n    if (words.length < 10) {\n        console.log('Text too short, needs at least 10 words. Word count:', words.length);\n        return false;\n    }\n\n    if (words.length > 2000) {\n        console.log('Text too long, exceeds 2000 words');\n        return false;\n    }\n\n    // Check for meaningful content\n    const meaningfulWords = words.filter(word => word.length >= 2);\n    const meaningfulRatio = meaningfulWords.length / words.length;\n\n    if (meaningfulRatio < 0.5) {\n        console.log('Too many short or meaningless words. Meaningful ratio:', meaningfulRatio);\n        return false;\n    }\n\n    // Check character distribution\n    const letterCount = cleanedText.replace(/[^a-zA-ZæøåÆØÅ]/g, '').length;\n    const totalLength = cleanedText.length;\n    const letterRatio = letterCount / totalLength;\n\n    if (letterRatio < 0.3) {  // Reduced from 0.4 to 0.3 to accommodate more special characters\n        console.log('Too few letters in text. Letter ratio:', letterRatio);\n        return false;\n    }\n\n    return true;\n};\n\n// Simple hash function for text\nconst hashText = (text) => {\n    let hash = 0;\n    for (let i = 0; i < text.length; i++) {\n        const char = text.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash;\n    }\n    return hash;\n};\n\n// Function to detect if text is in English\nconst isEnglishText = (text) => {\n    // Check for absence of Norwegian characters\n    const hasNorwegianChars = /[æøåÆØÅ]/.test(text);\n    if (hasNorwegianChars) return false;\n\n    // Common English words that don't exist in Norwegian\n    const englishWords = /\\b(the|and|is|are|was|were|this|that|these|those|with|for)\\b/i;\n    return englishWords.test(text);\n};\n\n// Function to translate text between Norwegian and English\nconst translateText = async (text, targetLanguage) => {\n    try {\n        const response = await openai.chat.completions.create({\n            model: \"gpt-4-turbo-preview\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are a professional translator specializing in academic and technical content. \n                    Translate the following text to ${targetLanguage === 'en' ? 'English' : 'Norwegian (Bokmål)'}, \n                    maintaining academic terminology and professional tone.`\n                },\n                {\n                    role: \"user\",\n                    content: text\n                }\n            ],\n            temperature: 0.3\n        });\n\n        await logApiCost(\n            'translation',\n            'gpt-4-turbo-preview',\n            response.usage.prompt_tokens,\n            response.usage.completion_tokens\n        );\n\n        return response.choices[0].message.content;\n    } catch (error) {\n        console.error('Translation error:', error);\n        throw error;\n    }\n};\n\n// Legg til export for generateEmbedding\nexport const generateEmbedding = async (text, translateFirst = false) => {\n    try {\n        let norwegianText = text;\n        let englishText = text;\n        const isEnglish = isEnglishText(text);\n\n        if (isEnglish) {\n            norwegianText = await translateText(text, 'nb');\n        } else if (translateFirst) {\n            englishText = await translateText(text, 'en');\n        }\n\n        const contextualizeText = (inputText) => `Task: Compare academic course descriptions to find similarities in learning outcomes, content, and themes.\n\nCourse Information:\n${inputText}\n\nConsider:\n- Learning outcomes and competencies\n- Course content and themes\n- Academic level and complexity\n- Teaching methods and approach`;\n\n        const [norwegianEmbedding, englishEmbedding] = await Promise.all([\n            openai.embeddings.create({\n                model: \"text-embedding-3-large\",\n                input: contextualizeText(norwegianText),\n                encoding_format: \"float\",\n                dimensions: 2000\n            }),\n            openai.embeddings.create({\n                model: \"text-embedding-3-large\",\n                input: contextualizeText(englishText),\n                encoding_format: \"float\",\n                dimensions: 2000\n            })\n        ]);\n\n        await logApiCost(\n            'embeddings',\n            'text-embedding-3-large',\n            norwegianEmbedding.usage.total_tokens\n        );\n        await logApiCost(\n            'embeddings',\n            'text-embedding-3-large',\n            englishEmbedding.usage.total_tokens\n        );\n\n        return {\n            norwegian: norwegianEmbedding.data[0].embedding,\n            english: englishEmbedding.data[0].embedding,\n            isEnglishInput: isEnglish\n        };\n    } catch (error) {\n        console.error('Error generating embeddings:', error);\n        throw error;\n    }\n};\n\n// Legg til export for generateOverlapExplanation\nexport const generateOverlapExplanation = async (courseA, courseB, similarityScore) => {\n    const cacheKey = `${courseA.name}-${courseB.kurskode}`;\n    \n    if (analysisCache.has(cacheKey)) {\n        return analysisCache.get(cacheKey);\n    }\n    \n    const isSameCourse = courseA.name === courseB.kursnavn ||\n        (courseA.code && courseA.code === courseB.kurskode);\n\n    const prompt = `\nDu er en akademisk rådgiver som skal forklare overlapp mellom to kurs. \n${isSameCourse ? 'Dette er samme kurs som sammenlignes med seg selv.' : ''}\nGenerer en strukturert forklaring på norsk (maks 250 ord) som sammenligner disse kursene:\n\nKurs A: ${courseA.name}\n${courseA.content}\n${courseA.literature ? `Pensum: ${courseA.literature}` : ''}\n\nKurs B: ${courseB.kursnavn} (${courseB.kurskode})\n${courseB.description || courseB.course_content || 'Ingen beskrivelse tilgjengelig'}\n${courseB.pensum ? `Pensum: ${courseB.pensum}` : ''}\n\nSimilaritet: ${similarityScore}%\n\nFormater svaret slik:\n\n### KURSSAMMENLIGNING\n▸ ${isSameCourse ? 'Dette er samme kurs sammenlignet med seg selv' : 'Kort introduksjon av begge kursene'}\n▸ Overordnet vurdering av overlapp (${similarityScore}% likhet)\n\n### HOVEDFOKUS\n• Sentrale temaer og konsepter${isSameCourse ? ' i kurset' : ' som overlapper'}\n${!isSameCourse ? `• Unike aspekter i ${courseA.name}\n• Unike aspekter i ${courseB.kursnavn}` : ''}\n\n### LÆRINGSUTBYTTE\n• Sentrale kompetanser${isSameCourse ? ' som kurset gir' : ' som overlapper'}:\n  - [Liste med kompetanser]\n${!isSameCourse ? `• Unike kompetanser i ${courseA.name}:\n  - [Liste med unike ferdigheter]\n• Unike kompetanser i ${courseB.kursnavn}:\n  - [Liste med unike ferdigheter]` : ''}\n\n### ANBEFALING\n▸ ${isSameCourse ? 'Dette er samme kurs, så det er ikke relevant å ta det flere ganger' : 'Er det hensiktsmessig å ta begge kursene?'}\n${!isSameCourse ? `▸ Anbefalt rekkefølge (hvis relevant)\n▸ Målgruppe og tilpasning` : ''}`;\n\n    try {\n        const response = await openai.chat.completions.create({\n            model: \"gpt-3.5-turbo-0125\",  // Nyeste og billigste versjonen\n            messages: [{ role: \"user\", content: prompt }],\n            temperature: 0.7,\n            max_tokens: 1000\n        });\n\n        await logApiCost(\n            'explanations',\n            'gpt-3.5-turbo-0125',\n            response.usage.prompt_tokens,\n            response.usage.completion_tokens\n        );\n\n        const explanation = response.choices[0].message.content.trim();\n        analysisCache.set(cacheKey, explanation);\n        return explanation;\n    } catch (error) {\n        console.error('Error generating overlap explanation:', error);\n        throw error;\n    }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}