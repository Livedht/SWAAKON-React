{"ast":null,"code":"import OpenAI from 'openai';\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true\n});\n\n// Normalize the embedding vector to unit length\nconst normalizeVector = vector => {\n  const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n  return vector.map(val => val / magnitude);\n};\n\n// Clean and format text for validation\nconst cleanTextForValidation = text => {\n  // Remove bullet points and other special characters but keep the text\n  return text.replace(/[•·⋅‣⁃◦∙]/g, '') // Remove bullet points\n  .replace(/[\\n\\r]+/g, ' ') // Replace newlines with spaces\n  .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\n  .trim();\n};\n\n// Validate text input\nconst isValidInput = text => {\n  // First, let's clean the text for validation\n  const cleanedText = cleanTextForValidation(text);\n\n  // Split into words, filtering out empty strings\n  const words = cleanedText.split(/\\s+/).filter(word => word.length > 0);\n  console.log('Validation stats:', {\n    originalLength: text.length,\n    cleanedLength: cleanedText.length,\n    wordCount: words.length,\n    sampleWords: words.slice(0, 5)\n  });\n\n  // Check word count\n  if (words.length < 10) {\n    console.log('Text too short, needs at least 10 words. Word count:', words.length);\n    return false;\n  }\n  if (words.length > 2000) {\n    console.log('Text too long, exceeds 2000 words');\n    return false;\n  }\n\n  // Check for meaningful content\n  const meaningfulWords = words.filter(word => word.length >= 2);\n  const meaningfulRatio = meaningfulWords.length / words.length;\n  if (meaningfulRatio < 0.5) {\n    console.log('Too many short or meaningless words. Meaningful ratio:', meaningfulRatio);\n    return false;\n  }\n\n  // Check character distribution\n  const letterCount = cleanedText.replace(/[^a-zA-ZæøåÆØÅ]/g, '').length;\n  const totalLength = cleanedText.length;\n  const letterRatio = letterCount / totalLength;\n  if (letterRatio < 0.3) {\n    // Reduced from 0.4 to 0.3 to accommodate more special characters\n    console.log('Too few letters in text. Letter ratio:', letterRatio);\n    return false;\n  }\n  return true;\n};\n\n// Cache for translations\nconst translationCache = new Map();\n\n// Simple hash function for text\nconst hashText = text => {\n  let hash = 0;\n  for (let i = 0; i < text.length; i++) {\n    const char = text.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return hash;\n};\n\n// Function to detect if text is in English\nconst isEnglishText = text => {\n  // Check for absence of Norwegian characters\n  const hasNorwegianChars = /[æøåÆØÅ]/.test(text);\n  if (hasNorwegianChars) return false;\n\n  // Common English words that don't exist in Norwegian\n  const englishWords = /\\b(the|and|is|are|was|were|this|that|these|those|with|for)\\b/i;\n  return englishWords.test(text);\n};\n\n// Function to translate text between Norwegian and English\nconst translateText = async (text, targetLanguage) => {\n  try {\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4-turbo-preview\",\n      messages: [{\n        role: \"system\",\n        content: `You are a professional translator specializing in academic and technical content. \n                    Translate the following text to ${targetLanguage === 'en' ? 'English' : 'Norwegian (Bokmål)'}, \n                    maintaining academic terminology and professional tone. \n                    Keep the structure and formatting of the original text.\n                    For Norwegian translations, use modern Bokmål.`\n      }, {\n        role: \"user\",\n        content: text\n      }],\n      temperature: 0.3\n    });\n    return response.choices[0].message.content;\n  } catch (error) {\n    console.error('Translation error:', error);\n    throw error;\n  }\n};\n\n// Generate embedding for text\nexport const generateEmbedding = async (text, translateFirst = false) => {\n  try {\n    let norwegianText = text;\n    let englishText = text;\n    const isEnglish = isEnglishText(text);\n    console.log('Input text language detection:', {\n      isEnglish,\n      textSample: text.slice(0, 100) + '...'\n    });\n\n    // Handle translations if needed\n    if (isEnglish) {\n      // If text is English, translate to Norwegian\n      norwegianText = await translateText(text, 'nb');\n      console.log('Translated to Norwegian');\n    } else if (translateFirst) {\n      // If text is Norwegian and translation is requested, translate to English\n      englishText = await translateText(text, 'en');\n      console.log('Translated to English');\n    }\n\n    // Add context about the task\n    const contextualizeText = inputText => `Task: Compare academic course descriptions to find similarities in learning outcomes, content, and themes.\n\nCourse Information:\n${inputText}\n\nConsider:\n- Learning outcomes and competencies\n- Course content and themes\n- Academic level and complexity\n- Teaching methods and approach`;\n\n    // Generate embeddings for both language versions\n    const [norwegianEmbedding, englishEmbedding] = await Promise.all([openai.embeddings.create({\n      model: \"text-embedding-3-large\",\n      input: contextualizeText(norwegianText),\n      encoding_format: \"float\",\n      dimensions: 2000\n    }), openai.embeddings.create({\n      model: \"text-embedding-3-large\",\n      input: contextualizeText(englishText),\n      encoding_format: \"float\",\n      dimensions: 2000\n    })]);\n    console.log('Generated embeddings for both language versions:', {\n      norwegianLength: norwegianEmbedding.data[0].embedding.length,\n      englishLength: englishEmbedding.data[0].embedding.length\n    });\n\n    // Return both embeddings\n    return {\n      norwegian: norwegianEmbedding.data[0].embedding,\n      english: englishEmbedding.data[0].embedding,\n      isEnglishInput: isEnglish\n    };\n  } catch (error) {\n    console.error('Error generating embeddings:', error);\n    throw error;\n  }\n};\nexport const generateOverlapExplanation = async (courseA, courseB, similarityScore) => {\n  const isSameCourse = courseA.name === courseB.kursnavn || courseA.code && courseA.code === courseB.kurskode;\n  const prompt = `\nDu er en akademisk rådgiver som skal forklare overlapp mellom to kurs. \n${isSameCourse ? 'Dette er samme kurs som sammenlignes med seg selv.' : ''}\nGenerer en strukturert forklaring på norsk (maks 250 ord) som sammenligner disse kursene:\n\nKurs A: ${courseA.name}\n${courseA.content}\n${courseA.literature ? `Pensum: ${courseA.literature}` : ''}\n\nKurs B: ${courseB.kursnavn} (${courseB.kurskode})\n${courseB.description || courseB.course_content || 'Ingen beskrivelse tilgjengelig'}\n${courseB.pensum ? `Pensum: ${courseB.pensum}` : ''}\n\nSimilaritet: ${similarityScore}%\n\nFormater svaret slik, og bruk NØYAKTIG denne formateringen:\n\n### KURSSAMMENLIGNING\n▸ ${isSameCourse ? 'Dette er samme kurs sammenlignet med seg selv' : 'Kort introduksjon av begge kursene'}\n▸ Overordnet vurdering av overlapp (${similarityScore}% likhet)\n\n### HOVEDFOKUS\n• Sentrale temaer og konsepter${isSameCourse ? ' i kurset' : ' som overlapper'}\n${!isSameCourse ? `• Unike aspekter i ${courseA.name}\n• Unike aspekter i ${courseB.kursnavn}` : ''}\n\n### LÆRINGSUTBYTTE\n• Sentrale kompetanser${isSameCourse ? ' som kurset gir' : ' som overlapper'}:\n  - [Liste med kompetanser]\n${!isSameCourse ? `• Unike kompetanser i ${courseA.name}:\n  - [Liste med unike ferdigheter]\n• Unike kompetanser i ${courseB.kursnavn}:\n  - [Liste med unike ferdigheter]` : ''}\n\n${courseA.literature || courseB.pensum ? `### PENSUM\n• ${isSameCourse ? 'Kursets pensum og kilder' : 'Overlappende litteratur og kilder'}\n${!isSameCourse ? `• Unike kilder i ${courseA.name}\n• Unike kilder i ${courseB.kursnavn}` : ''}` : ''}\n\n### ANBEFALING\n▸ ${isSameCourse ? 'Dette er samme kurs, så det er ikke relevant å ta det flere ganger' : 'Er det hensiktsmessig å ta begge kursene?'}\n${!isSameCourse ? `▸ Anbefalt rekkefølge (hvis relevant)\n▸ Målgruppe og tilpasning` : ''}\n\nBruk kun punktlister (• og -) og piler (▸) som vist over.\nUnngå bruk av stjerner (**) eller annen formatering.\nHold teksten konsis og fokusert på praktisk informasjon.\n${isSameCourse ? 'Siden dette er samme kurs, fokuser på å beskrive kursets innhold og læringsutbytte, ikke på forskjeller.' : ''}`;\n  try {\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4-turbo-preview\",\n      messages: [{\n        role: \"user\",\n        content: prompt\n      }],\n      temperature: 0.7,\n      max_tokens: 1000\n    });\n    const explanation = response.choices[0].message.content.trim();\n    console.log('Generated explanation:', explanation);\n    return explanation;\n  } catch (error) {\n    console.error('Error generating overlap explanation:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["OpenAI","openai","apiKey","process","env","REACT_APP_OPENAI_API_KEY","dangerouslyAllowBrowser","normalizeVector","vector","magnitude","Math","sqrt","reduce","sum","val","map","cleanTextForValidation","text","replace","trim","isValidInput","cleanedText","words","split","filter","word","length","console","log","originalLength","cleanedLength","wordCount","sampleWords","slice","meaningfulWords","meaningfulRatio","letterCount","totalLength","letterRatio","translationCache","Map","hashText","hash","i","char","charCodeAt","isEnglishText","hasNorwegianChars","test","englishWords","translateText","targetLanguage","response","chat","completions","create","model","messages","role","content","temperature","choices","message","error","generateEmbedding","translateFirst","norwegianText","englishText","isEnglish","textSample","contextualizeText","inputText","norwegianEmbedding","englishEmbedding","Promise","all","embeddings","input","encoding_format","dimensions","norwegianLength","data","embedding","englishLength","norwegian","english","isEnglishInput","generateOverlapExplanation","courseA","courseB","similarityScore","isSameCourse","name","kursnavn","code","kurskode","prompt","literature","description","course_content","pensum","max_tokens","explanation"],"sources":["C:/Users/A1510207/OneDrive - BI Norwegian Business School (BIEDU)/Documents/Dev prosjekter/SWAAKON-React/src/services/openai.js"],"sourcesContent":["import OpenAI from 'openai';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.REACT_APP_OPENAI_API_KEY,\r\n    dangerouslyAllowBrowser: true\r\n});\r\n\r\n// Normalize the embedding vector to unit length\r\nconst normalizeVector = (vector) => {\r\n    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\r\n    return vector.map(val => val / magnitude);\r\n};\r\n\r\n// Clean and format text for validation\r\nconst cleanTextForValidation = (text) => {\r\n    // Remove bullet points and other special characters but keep the text\r\n    return text\r\n        .replace(/[•·⋅‣⁃◦∙]/g, '') // Remove bullet points\r\n        .replace(/[\\n\\r]+/g, ' ') // Replace newlines with spaces\r\n        .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\r\n        .trim();\r\n};\r\n\r\n// Validate text input\r\nconst isValidInput = (text) => {\r\n    // First, let's clean the text for validation\r\n    const cleanedText = cleanTextForValidation(text);\r\n\r\n    // Split into words, filtering out empty strings\r\n    const words = cleanedText.split(/\\s+/).filter(word => word.length > 0);\r\n\r\n    console.log('Validation stats:', {\r\n        originalLength: text.length,\r\n        cleanedLength: cleanedText.length,\r\n        wordCount: words.length,\r\n        sampleWords: words.slice(0, 5)\r\n    });\r\n\r\n    // Check word count\r\n    if (words.length < 10) {\r\n        console.log('Text too short, needs at least 10 words. Word count:', words.length);\r\n        return false;\r\n    }\r\n\r\n    if (words.length > 2000) {\r\n        console.log('Text too long, exceeds 2000 words');\r\n        return false;\r\n    }\r\n\r\n    // Check for meaningful content\r\n    const meaningfulWords = words.filter(word => word.length >= 2);\r\n    const meaningfulRatio = meaningfulWords.length / words.length;\r\n\r\n    if (meaningfulRatio < 0.5) {\r\n        console.log('Too many short or meaningless words. Meaningful ratio:', meaningfulRatio);\r\n        return false;\r\n    }\r\n\r\n    // Check character distribution\r\n    const letterCount = cleanedText.replace(/[^a-zA-ZæøåÆØÅ]/g, '').length;\r\n    const totalLength = cleanedText.length;\r\n    const letterRatio = letterCount / totalLength;\r\n\r\n    if (letterRatio < 0.3) {  // Reduced from 0.4 to 0.3 to accommodate more special characters\r\n        console.log('Too few letters in text. Letter ratio:', letterRatio);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// Cache for translations\r\nconst translationCache = new Map();\r\n\r\n// Simple hash function for text\r\nconst hashText = (text) => {\r\n    let hash = 0;\r\n    for (let i = 0; i < text.length; i++) {\r\n        const char = text.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash = hash & hash;\r\n    }\r\n    return hash;\r\n};\r\n\r\n// Function to detect if text is in English\r\nconst isEnglishText = (text) => {\r\n    // Check for absence of Norwegian characters\r\n    const hasNorwegianChars = /[æøåÆØÅ]/.test(text);\r\n    if (hasNorwegianChars) return false;\r\n\r\n    // Common English words that don't exist in Norwegian\r\n    const englishWords = /\\b(the|and|is|are|was|were|this|that|these|those|with|for)\\b/i;\r\n    return englishWords.test(text);\r\n};\r\n\r\n// Function to translate text between Norwegian and English\r\nconst translateText = async (text, targetLanguage) => {\r\n    try {\r\n        const response = await openai.chat.completions.create({\r\n            model: \"gpt-4-turbo-preview\",\r\n            messages: [\r\n                {\r\n                    role: \"system\",\r\n                    content: `You are a professional translator specializing in academic and technical content. \r\n                    Translate the following text to ${targetLanguage === 'en' ? 'English' : 'Norwegian (Bokmål)'}, \r\n                    maintaining academic terminology and professional tone. \r\n                    Keep the structure and formatting of the original text.\r\n                    For Norwegian translations, use modern Bokmål.`\r\n                },\r\n                {\r\n                    role: \"user\",\r\n                    content: text\r\n                }\r\n            ],\r\n            temperature: 0.3\r\n        });\r\n\r\n        return response.choices[0].message.content;\r\n    } catch (error) {\r\n        console.error('Translation error:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\n// Generate embedding for text\r\nexport const generateEmbedding = async (text, translateFirst = false) => {\r\n    try {\r\n        let norwegianText = text;\r\n        let englishText = text;\r\n        const isEnglish = isEnglishText(text);\r\n\r\n        console.log('Input text language detection:', {\r\n            isEnglish,\r\n            textSample: text.slice(0, 100) + '...'\r\n        });\r\n\r\n        // Handle translations if needed\r\n        if (isEnglish) {\r\n            // If text is English, translate to Norwegian\r\n            norwegianText = await translateText(text, 'nb');\r\n            console.log('Translated to Norwegian');\r\n        } else if (translateFirst) {\r\n            // If text is Norwegian and translation is requested, translate to English\r\n            englishText = await translateText(text, 'en');\r\n            console.log('Translated to English');\r\n        }\r\n\r\n        // Add context about the task\r\n        const contextualizeText = (inputText) => `Task: Compare academic course descriptions to find similarities in learning outcomes, content, and themes.\r\n\r\nCourse Information:\r\n${inputText}\r\n\r\nConsider:\r\n- Learning outcomes and competencies\r\n- Course content and themes\r\n- Academic level and complexity\r\n- Teaching methods and approach`;\r\n\r\n        // Generate embeddings for both language versions\r\n        const [norwegianEmbedding, englishEmbedding] = await Promise.all([\r\n            openai.embeddings.create({\r\n                model: \"text-embedding-3-large\",\r\n                input: contextualizeText(norwegianText),\r\n                encoding_format: \"float\",\r\n                dimensions: 2000\r\n            }),\r\n            openai.embeddings.create({\r\n                model: \"text-embedding-3-large\",\r\n                input: contextualizeText(englishText),\r\n                encoding_format: \"float\",\r\n                dimensions: 2000\r\n            })\r\n        ]);\r\n\r\n        console.log('Generated embeddings for both language versions:', {\r\n            norwegianLength: norwegianEmbedding.data[0].embedding.length,\r\n            englishLength: englishEmbedding.data[0].embedding.length\r\n        });\r\n\r\n        // Return both embeddings\r\n        return {\r\n            norwegian: norwegianEmbedding.data[0].embedding,\r\n            english: englishEmbedding.data[0].embedding,\r\n            isEnglishInput: isEnglish\r\n        };\r\n    } catch (error) {\r\n        console.error('Error generating embeddings:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport const generateOverlapExplanation = async (courseA, courseB, similarityScore) => {\r\n    const isSameCourse = courseA.name === courseB.kursnavn ||\r\n        (courseA.code && courseA.code === courseB.kurskode);\r\n\r\n    const prompt = `\r\nDu er en akademisk rådgiver som skal forklare overlapp mellom to kurs. \r\n${isSameCourse ? 'Dette er samme kurs som sammenlignes med seg selv.' : ''}\r\nGenerer en strukturert forklaring på norsk (maks 250 ord) som sammenligner disse kursene:\r\n\r\nKurs A: ${courseA.name}\r\n${courseA.content}\r\n${courseA.literature ? `Pensum: ${courseA.literature}` : ''}\r\n\r\nKurs B: ${courseB.kursnavn} (${courseB.kurskode})\r\n${courseB.description || courseB.course_content || 'Ingen beskrivelse tilgjengelig'}\r\n${courseB.pensum ? `Pensum: ${courseB.pensum}` : ''}\r\n\r\nSimilaritet: ${similarityScore}%\r\n\r\nFormater svaret slik, og bruk NØYAKTIG denne formateringen:\r\n\r\n### KURSSAMMENLIGNING\r\n▸ ${isSameCourse ? 'Dette er samme kurs sammenlignet med seg selv' : 'Kort introduksjon av begge kursene'}\r\n▸ Overordnet vurdering av overlapp (${similarityScore}% likhet)\r\n\r\n### HOVEDFOKUS\r\n• Sentrale temaer og konsepter${isSameCourse ? ' i kurset' : ' som overlapper'}\r\n${!isSameCourse ? `• Unike aspekter i ${courseA.name}\r\n• Unike aspekter i ${courseB.kursnavn}` : ''}\r\n\r\n### LÆRINGSUTBYTTE\r\n• Sentrale kompetanser${isSameCourse ? ' som kurset gir' : ' som overlapper'}:\r\n  - [Liste med kompetanser]\r\n${!isSameCourse ? `• Unike kompetanser i ${courseA.name}:\r\n  - [Liste med unike ferdigheter]\r\n• Unike kompetanser i ${courseB.kursnavn}:\r\n  - [Liste med unike ferdigheter]` : ''}\r\n\r\n${courseA.literature || courseB.pensum ? `### PENSUM\r\n• ${isSameCourse ? 'Kursets pensum og kilder' : 'Overlappende litteratur og kilder'}\r\n${!isSameCourse ? `• Unike kilder i ${courseA.name}\r\n• Unike kilder i ${courseB.kursnavn}` : ''}` : ''}\r\n\r\n### ANBEFALING\r\n▸ ${isSameCourse ? 'Dette er samme kurs, så det er ikke relevant å ta det flere ganger' : 'Er det hensiktsmessig å ta begge kursene?'}\r\n${!isSameCourse ? `▸ Anbefalt rekkefølge (hvis relevant)\r\n▸ Målgruppe og tilpasning` : ''}\r\n\r\nBruk kun punktlister (• og -) og piler (▸) som vist over.\r\nUnngå bruk av stjerner (**) eller annen formatering.\r\nHold teksten konsis og fokusert på praktisk informasjon.\r\n${isSameCourse ? 'Siden dette er samme kurs, fokuser på å beskrive kursets innhold og læringsutbytte, ikke på forskjeller.' : ''}`;\r\n\r\n    try {\r\n        const response = await openai.chat.completions.create({\r\n            model: \"gpt-4-turbo-preview\",\r\n            messages: [{ role: \"user\", content: prompt }],\r\n            temperature: 0.7,\r\n            max_tokens: 1000\r\n        });\r\n\r\n        const explanation = response.choices[0].message.content.trim();\r\n        console.log('Generated explanation:', explanation);\r\n        return explanation;\r\n    } catch (error) {\r\n        console.error('Error generating overlap explanation:', error);\r\n        throw error;\r\n    }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}